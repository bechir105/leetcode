[
  {
    "title": "Two Sum",
    "openai_response": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in hashmap:\n                return [hashmap[complement], i]\n            hashmap[num] = i",
    "metadata": {
      "function_name": "twoSum",
      "parameters": ["nums", "target"],
      "example_input": {
        "nums": [2, 7, 11, 15],
        "target": 9
      }
    }
  },
  {
    "title": "Zigzag Conversion",
    "openai_response": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        rows = [''] * numRows\n        cur_row = 0\n        going_down = False\n\n        for char in s:\n            rows[cur_row] += char\n            if cur_row == 0 or cur_row == numRows - 1:\n                going_down = not going_down\n            cur_row += 1 if going_down else -1\n\n        return ''.join(rows)",
    "metadata": {
      "function_name": "convert",
      "parameters": ["s", "numRows"],
      "example_input": {
        "s": "PAYPALISHIRING",
        "numRows": 3
      }
    }
  },

  {
    "title": "Median of Two Sorted Arrays",
    "openai_response": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        if n == 0:\n            raise ValueError\n\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n            if i < m and nums2[j-1] > nums1[i]:\n                # i is too small, must increase it\n                imin = i + 1\n            elif i > 0 and nums1[i-1] > nums2[j]:\n                # i is too big, must decrease it\n                imax = i - 1\n            else:\n                # i is perfect\n\n                if i == 0: max_of_left = nums2[j-1]\n                elif j == 0: max_of_left = nums1[i-1]\n                else: max_of_left = max(nums1[i-1], nums2[j-1])\n\n                if (m + n) % 2 == 1:\n                    return max_of_left\n\n                if i == m: min_of_right = nums2[j]\n                elif j == n: min_of_right = nums1[i]\n                else: min_of_right = min(nums1[i], nums2[j])\n\n                return (max_of_left + min_of_right) / 2.0",
    "metadata": {
      "function_name": "findMedianSortedArrays",
      "parameters": ["nums1", "nums2"],
      "example_input": {
        "nums1": [1, 3],
        "nums2": [2]
      }
    }
  },
  {
    "title": "Longest Palindromic Substring",
    "openai_response": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        start, end, maxlength = 0, 0, 0\n        for i in range(len(s)):\n            len1 = self.expandFromMiddle(s, i, i)\n            len2 = self.expandFromMiddle(s, i, i+1)\n            length = max(len1, len2)\n            if length > maxlength:\n                maxlength = length\n                start = i - (length - 1) // 2\n                end = i + length // 2\n        return s[start:end+1]\n    \n    def expandFromMiddle(self, s: str, left: int, right: int) -> int:\n        if left < 0 or right >= len(s) or s[left] != s[right]:\n            return 0\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1",
    "metadata": {
      "function_name": "longestPalindrome",
      "parameters": ["s"],
      "example_input": {
        "s": "babad"
      }
    }
  }
]
